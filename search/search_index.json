{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sudoku-tools \u00b6 Description \u00b6 This Python package is a collection of useful tools for generating, grading, solving, and transforming sudoku puzzles. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 python -m pip install sudoku-tools Usage \u00b6 The object can be constructed with a 1-dimensional board: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Feel free to check out the docs for more information. License \u00b6 This software is released under the terms of MIT license .","title":"Overview"},{"location":"#sudoku-tools","text":"","title":"sudoku-tools"},{"location":"#description","text":"This Python package is a collection of useful tools for generating, grading, solving, and transforming sudoku puzzles.","title":"Description"},{"location":"#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 python -m pip install sudoku-tools","title":"Installation"},{"location":"#usage","text":"The object can be constructed with a 1-dimensional board: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Feel free to check out the docs for more information.","title":"Usage"},{"location":"#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"docs/","text":"sudoku-tools \u00b6 Description \u00b6 This Python package is a collection of useful tools for generating, grading, solving, and transforming sudoku puzzles. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 pip install sudoku-tools Usage \u00b6 The object can be constructed with a 1-dimensional board: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Feel free to check out the docs for more information. License \u00b6 This software is released under the terms of MIT license .","title":"`sudoku-tools`"},{"location":"docs/#sudoku-tools","text":"","title":"sudoku-tools"},{"location":"docs/#description","text":"This Python package is a collection of useful tools for generating, grading, solving, and transforming sudoku puzzles.","title":"Description"},{"location":"docs/#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 pip install sudoku-tools","title":"Installation"},{"location":"docs/#usage","text":"The object can be constructed with a 1-dimensional board: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Feel free to check out the docs for more information.","title":"Usage"},{"location":"docs/#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"docs/documentation/","text":"sudoku \u00b6 sudoku.strategies \u00b6 sudoku.strategies.hidden_subset \u00b6 HiddenSubset Objects \u00b6 1 class HiddenSubset ( Strategy ) Apply the Hidden Subset strategy HiddenSingle Objects \u00b6 1 class HiddenSingle ( HiddenSubset ) The Hidden Single strategy sudoku.strategies.refresh_candidates \u00b6 RefreshCandidates Objects \u00b6 1 class RefreshCandidates ( Strategy ) Remove invalid candidates from each cell sudoku.strategies.strategy \u00b6 Strategy Objects \u00b6 1 class Strategy () Also known as a Solving Technique Attributes : name str - The name of the strategy difficulty float - The difficulty rating of the strategy defined with respect to eliminating a single candidate __call__ \u00b6 1 | __call__ ( puzzle : Puzzle [ T ]) -> int Apply the strategy to a given sudoku puzzle Arguments : puzzle Puzzle[T] - The sudoku puzzle Returns : int - The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle sudoku.strategies.naked_subset \u00b6 NakedSubset Objects \u00b6 1 class NakedSubset ( Strategy ) Apply the Naked Subset strategy NakedSingle Objects \u00b6 1 class NakedSingle ( NakedSubset ) The Naked Single strategy ForcedDigit Objects \u00b6 1 class ForcedDigit ( NakedSingle ) Alias for the [[NakedSingle]] strategy SoleCandidate Objects \u00b6 1 class SoleCandidate ( NakedSingle ) Alias for the [[NakedSingle]] strategy NakedDouble Objects \u00b6 1 class NakedDouble ( NakedSubset ) Apply the Naked Double strategy NakedTriple Objects \u00b6 1 class NakedTriple ( NakedSubset ) Apply the Naked Triple strategy NakedQuad Objects \u00b6 1 class NakedQuad ( NakedSubset ) Apply the Naked Quad strategy sudoku.puzzle \u00b6 Puzzle Objects \u00b6 1 class Puzzle ( Generic [ T ]) The base class for a sudoku puzzle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. <a name=\"sudoku.puzzle.Puzzle.Tokens\"></a> ## Tokens Objects ```python class Tokens(List[T]) A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. swap \u00b6 1 | swap ( i : int , j : int ) Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Arguments : i int - The integer alias value associated with a token j int - The integer alias value associated with a token shuffle \u00b6 1 | shuffle () Randomly swap the tokens in the puzzle by randomizing their integer aliases. Cell Objects \u00b6 1 class Cell () The class for an individual cell in the sudoku puzzle Attributes : puzzle Puzzle[T] - The corresponding sudoku puzzle candidates Set[int] - A set of the cell's remaining candidates value int - The value of the sudoku cell or 0 if it is blank. is_blank \u00b6 1 | is_blank () -> bool Check whether the cell is blank or has a value. Returns : bool - A boolean value for whether the cell is blank. has_conflicts \u00b6 1 | has_conflicts () -> bool A method to determine if the board has any conflicting cells Returns : bool - True if the board has conflicts, False otherwise __init__ \u00b6 1 | __init__ ( puzzle : Iterable [ T ], blank : T = None ) The object can be constructed with any 1-dimensional iterable: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Arguments : puzzle Iterable[T] - An iterable representing a Sudoku puzzle blank T - The value used to represent a blank cell reflect \u00b6 1 | reflect ( direction : str = \"horizontal\" ) -> None Reflect the Sudoku board horizontally or vertically Arguments : direction str - The direction over which to reflect. Defaults to \"horizontal\". rotate \u00b6 1 | rotate ( rotations = 1 ) -> None Rotate the Sudoku board clockwise a given number in times. Arguments : rotations int - The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. transpose \u00b6 1 | transpose () -> None Switch the rows and columns in the Sudoku board shuffle \u00b6 1 | shuffle () -> None Shuffle the board using rotations, reflections, and token-swapping to_1D \u00b6 1 | to_1D () -> List [ T ] A method for getting back the Sudoku board as a 1-dimensional array Returns : List[T] - A 1D array of the Sudoku board in the board's original type to_2D \u00b6 1 | to_2D () -> List [ List [ T ]] A method for getting back the Sudoku board as a 2-dimensional array Returns : List[T] - A 2D array of the Sudoku board in the board's original type to_string \u00b6 1 | to_string () -> str A method for getting back the Sudoku board as a string Returns : str - A string representation in the Sudoku board to_formatted_string \u00b6 1 | to_formatted_string ( cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" ) -> str A method for getting back the Sudoku board as a formatted string Returns : str - A formatted string representing the Sudoku board is_solved \u00b6 1 | is_solved () -> bool Check whether the puzzle is solved Returns : bool - A boolean value indicating whether the puzzle is solved solve \u00b6 1 | solve ( solver : Solver = StrategySolver ) -> bool Solve the puzzle using one of the solvers Arguments : solver Solver, optional - The solver used to solve the puzzle. Defaults to StrategySolver. Returns : bool - A boolean value indicating whether the puzzle could be solved has_solution \u00b6 1 | has_solution () -> bool Check whether the puzzle is able to be solved Returns : bool - A boolean value indicating whether the puzzle has a solution rate \u00b6 1 | rate () -> float Calculate the difficulty of solving the puzzle Returns : float - A difficulty rating between 0 and 1 sudoku.solvers \u00b6 sudoku.solvers.solver \u00b6 Solver Objects \u00b6 1 class Solver () solve \u00b6 1 | solve ( puzzle : Puzzle [ T ]) -> None Solve the puzzle in place. Arguments : puzzle Puzzle - The puzzle to be solved. sudoku.solvers.strategy_solver \u00b6 essential_strategies \u00b6 1 essential_strategies ( order : int ) -> Generator [ Strategy ] Generator for strategies from simple to complex with a given order StrategySolver Objects \u00b6 1 class StrategySolver ( Solver ) solve \u00b6 1 | solve ( puzzle : Puzzle [ T ]) -> bool Solve the puzzle using strategies Returns : bool - A boolean value indicating whether the puzzle could be solved sudoku.examples \u00b6 sudoku.examples.rate \u00b6 sudoku.examples.shuffle \u00b6 sudoku.examples.solve \u00b6 sudoku.examples.boards \u00b6","title":"Documentation"},{"location":"docs/documentation/#sudoku","text":"","title":"sudoku"},{"location":"docs/documentation/#sudokustrategies","text":"","title":"sudoku.strategies"},{"location":"docs/documentation/#sudokustrategieshidden_subset","text":"","title":"sudoku.strategies.hidden_subset"},{"location":"docs/documentation/#hiddensubset-objects","text":"1 class HiddenSubset ( Strategy ) Apply the Hidden Subset strategy","title":"HiddenSubset Objects"},{"location":"docs/documentation/#hiddensingle-objects","text":"1 class HiddenSingle ( HiddenSubset ) The Hidden Single strategy","title":"HiddenSingle Objects"},{"location":"docs/documentation/#sudokustrategiesrefresh_candidates","text":"","title":"sudoku.strategies.refresh_candidates"},{"location":"docs/documentation/#refreshcandidates-objects","text":"1 class RefreshCandidates ( Strategy ) Remove invalid candidates from each cell","title":"RefreshCandidates Objects"},{"location":"docs/documentation/#sudokustrategiesstrategy","text":"","title":"sudoku.strategies.strategy"},{"location":"docs/documentation/#strategy-objects","text":"1 class Strategy () Also known as a Solving Technique Attributes : name str - The name of the strategy difficulty float - The difficulty rating of the strategy defined with respect to eliminating a single candidate","title":"Strategy Objects"},{"location":"docs/documentation/#__call__","text":"1 | __call__ ( puzzle : Puzzle [ T ]) -> int Apply the strategy to a given sudoku puzzle Arguments : puzzle Puzzle[T] - The sudoku puzzle Returns : int - The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle","title":"__call__"},{"location":"docs/documentation/#sudokustrategiesnaked_subset","text":"","title":"sudoku.strategies.naked_subset"},{"location":"docs/documentation/#nakedsubset-objects","text":"1 class NakedSubset ( Strategy ) Apply the Naked Subset strategy","title":"NakedSubset Objects"},{"location":"docs/documentation/#nakedsingle-objects","text":"1 class NakedSingle ( NakedSubset ) The Naked Single strategy","title":"NakedSingle Objects"},{"location":"docs/documentation/#forceddigit-objects","text":"1 class ForcedDigit ( NakedSingle ) Alias for the [[NakedSingle]] strategy","title":"ForcedDigit Objects"},{"location":"docs/documentation/#solecandidate-objects","text":"1 class SoleCandidate ( NakedSingle ) Alias for the [[NakedSingle]] strategy","title":"SoleCandidate Objects"},{"location":"docs/documentation/#nakeddouble-objects","text":"1 class NakedDouble ( NakedSubset ) Apply the Naked Double strategy","title":"NakedDouble Objects"},{"location":"docs/documentation/#nakedtriple-objects","text":"1 class NakedTriple ( NakedSubset ) Apply the Naked Triple strategy","title":"NakedTriple Objects"},{"location":"docs/documentation/#nakedquad-objects","text":"1 class NakedQuad ( NakedSubset ) Apply the Naked Quad strategy","title":"NakedQuad Objects"},{"location":"docs/documentation/#sudokupuzzle","text":"","title":"sudoku.puzzle"},{"location":"docs/documentation/#puzzle-objects","text":"1 class Puzzle ( Generic [ T ]) The base class for a sudoku puzzle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. <a name=\"sudoku.puzzle.Puzzle.Tokens\"></a> ## Tokens Objects ```python class Tokens(List[T]) A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list.","title":"Puzzle Objects"},{"location":"docs/documentation/#swap","text":"1 | swap ( i : int , j : int ) Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Arguments : i int - The integer alias value associated with a token j int - The integer alias value associated with a token","title":"swap"},{"location":"docs/documentation/#shuffle","text":"1 | shuffle () Randomly swap the tokens in the puzzle by randomizing their integer aliases.","title":"shuffle"},{"location":"docs/documentation/#cell-objects","text":"1 class Cell () The class for an individual cell in the sudoku puzzle Attributes : puzzle Puzzle[T] - The corresponding sudoku puzzle candidates Set[int] - A set of the cell's remaining candidates value int - The value of the sudoku cell or 0 if it is blank.","title":"Cell Objects"},{"location":"docs/documentation/#is_blank","text":"1 | is_blank () -> bool Check whether the cell is blank or has a value. Returns : bool - A boolean value for whether the cell is blank.","title":"is_blank"},{"location":"docs/documentation/#has_conflicts","text":"1 | has_conflicts () -> bool A method to determine if the board has any conflicting cells Returns : bool - True if the board has conflicts, False otherwise","title":"has_conflicts"},{"location":"docs/documentation/#__init__","text":"1 | __init__ ( puzzle : Iterable [ T ], blank : T = None ) The object can be constructed with any 1-dimensional iterable: 1 2 arr_1d = [ 1 , 0 , 3 , 4 , 0 , 4 , 1 , 0 , 0 , 3 , 0 , 1 , 4 , 0 , 2 , 3 ] puzzle = Puzzle ( arr_1d , 0 ) Arguments : puzzle Iterable[T] - An iterable representing a Sudoku puzzle blank T - The value used to represent a blank cell","title":"__init__"},{"location":"docs/documentation/#reflect","text":"1 | reflect ( direction : str = \"horizontal\" ) -> None Reflect the Sudoku board horizontally or vertically Arguments : direction str - The direction over which to reflect. Defaults to \"horizontal\".","title":"reflect"},{"location":"docs/documentation/#rotate","text":"1 | rotate ( rotations = 1 ) -> None Rotate the Sudoku board clockwise a given number in times. Arguments : rotations int - The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1.","title":"rotate"},{"location":"docs/documentation/#transpose","text":"1 | transpose () -> None Switch the rows and columns in the Sudoku board","title":"transpose"},{"location":"docs/documentation/#shuffle_1","text":"1 | shuffle () -> None Shuffle the board using rotations, reflections, and token-swapping","title":"shuffle"},{"location":"docs/documentation/#to_1d","text":"1 | to_1D () -> List [ T ] A method for getting back the Sudoku board as a 1-dimensional array Returns : List[T] - A 1D array of the Sudoku board in the board's original type","title":"to_1D"},{"location":"docs/documentation/#to_2d","text":"1 | to_2D () -> List [ List [ T ]] A method for getting back the Sudoku board as a 2-dimensional array Returns : List[T] - A 2D array of the Sudoku board in the board's original type","title":"to_2D"},{"location":"docs/documentation/#to_string","text":"1 | to_string () -> str A method for getting back the Sudoku board as a string Returns : str - A string representation in the Sudoku board","title":"to_string"},{"location":"docs/documentation/#to_formatted_string","text":"1 | to_formatted_string ( cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" ) -> str A method for getting back the Sudoku board as a formatted string Returns : str - A formatted string representing the Sudoku board","title":"to_formatted_string"},{"location":"docs/documentation/#is_solved","text":"1 | is_solved () -> bool Check whether the puzzle is solved Returns : bool - A boolean value indicating whether the puzzle is solved","title":"is_solved"},{"location":"docs/documentation/#solve","text":"1 | solve ( solver : Solver = StrategySolver ) -> bool Solve the puzzle using one of the solvers Arguments : solver Solver, optional - The solver used to solve the puzzle. Defaults to StrategySolver. Returns : bool - A boolean value indicating whether the puzzle could be solved","title":"solve"},{"location":"docs/documentation/#has_solution","text":"1 | has_solution () -> bool Check whether the puzzle is able to be solved Returns : bool - A boolean value indicating whether the puzzle has a solution","title":"has_solution"},{"location":"docs/documentation/#rate","text":"1 | rate () -> float Calculate the difficulty of solving the puzzle Returns : float - A difficulty rating between 0 and 1","title":"rate"},{"location":"docs/documentation/#sudokusolvers","text":"","title":"sudoku.solvers"},{"location":"docs/documentation/#sudokusolverssolver","text":"","title":"sudoku.solvers.solver"},{"location":"docs/documentation/#solver-objects","text":"1 class Solver ()","title":"Solver Objects"},{"location":"docs/documentation/#solve_1","text":"1 | solve ( puzzle : Puzzle [ T ]) -> None Solve the puzzle in place. Arguments : puzzle Puzzle - The puzzle to be solved.","title":"solve"},{"location":"docs/documentation/#sudokusolversstrategy_solver","text":"","title":"sudoku.solvers.strategy_solver"},{"location":"docs/documentation/#essential_strategies","text":"1 essential_strategies ( order : int ) -> Generator [ Strategy ] Generator for strategies from simple to complex with a given order","title":"essential_strategies"},{"location":"docs/documentation/#strategysolver-objects","text":"1 class StrategySolver ( Solver )","title":"StrategySolver Objects"},{"location":"docs/documentation/#solve_2","text":"1 | solve ( puzzle : Puzzle [ T ]) -> bool Solve the puzzle using strategies Returns : bool - A boolean value indicating whether the puzzle could be solved","title":"solve"},{"location":"docs/documentation/#sudokuexamples","text":"","title":"sudoku.examples"},{"location":"docs/documentation/#sudokuexamplesrate","text":"","title":"sudoku.examples.rate"},{"location":"docs/documentation/#sudokuexamplesshuffle","text":"","title":"sudoku.examples.shuffle"},{"location":"docs/documentation/#sudokuexamplessolve","text":"","title":"sudoku.examples.solve"},{"location":"docs/documentation/#sudokuexamplesboards","text":"","title":"sudoku.examples.boards"},{"location":"reference/sudoku/","text":"Module sudoku \u00b6 None None View Source from .puzzle import Puzzle __all__ = ( \"Puzzle\" ,) Sub-modules \u00b6 sudoku.examples sudoku.puzzle sudoku.solvers sudoku.strategies Classes \u00b6 Puzzle \u00b6 1 2 3 4 class Puzzle ( puzzle : 'Sequence[T]' , blank : 'T' ) Attributes \u00b6 Name Type Description Default Generic T The base type for each token in the sudoku puzzle None tokens Tokens A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. None order int The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. None cells List[Cell] A list of all the cells in the sudoku puzzle. None View Source class Puzzle ( Generic [ T ] ) : \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ] ) : \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ) : \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ] , self [ j ] = self [ j ] , self [ i ] def shuffle ( self ) : \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1: ] random . shuffle ( tokens ) self [ 1: ] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ] , value : int ) : self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order ) } self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ) : if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order ) } else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ) : r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ) : r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ) : if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank () : yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ) : if not cell . is_blank () : for _ , peer in self . _peers ( i ) : if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ] , blank : T ) : \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ( [ blank ] ) self . cells = np . empty ( len ( puzzle ), dtype = object ). tolist () for i , token in enumerate ( puzzle ) : try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices[0 ] ] for i in range ( 1 , len ( indices )) : self . cells [ indices[i - 1 ] ] = self . cells [ indices[i ] ] self . cells [ indices[-1 ] ] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ) : self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str, int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy.name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy.name ] rating += difficulty * ( eliminations / max_eliminations ) return rating Ancestors (in MRO) \u00b6 typing.Generic Class variables \u00b6 1 Cell 1 Tokens Instance variables \u00b6 1 cells 1 order 1 tokens Methods \u00b6 has_conflicts \u00b6 1 2 3 def has_conflicts ( self ) -> 'bool' A method to determine if the board has any conflicting cells Returns: Type Description bool True if the board has conflicts, False otherwise View Source def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False has_solution \u00b6 1 2 3 def has_solution ( self ) -> 'bool' Check whether the puzzle is able to be solved Returns: Type Description bool A boolean value indicating whether the puzzle has a solution View Source def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () is_solved \u00b6 1 2 3 def is_solved ( self ) -> 'bool' Check whether the puzzle is solved Returns: Type Description bool A boolean value indicating whether the puzzle is solved View Source def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () rate \u00b6 1 2 3 def rate ( self ) -> 'float' Calculate the difficulty of solving the puzzle Returns: Type Description float A difficulty rating between 0 and 1 View Source def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating reflect \u00b6 1 2 3 4 def reflect ( self , direction : 'str' = 'horizontal' ) -> 'None' Reflect the Sudoku board horizontally or vertically Parameters: Name Type Description Default direction str The direction over which to reflect. Defaults to \"horizontal\". \"horizontal\" View Source def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) rotate \u00b6 1 2 3 4 def rotate ( self , rotations = 1 ) -> 'None' Rotate the Sudoku board clockwise a given number in times. Parameters: Name Type Description Default rotations int The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. None View Source def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) shuffle \u00b6 1 2 3 def shuffle ( self ) -> 'None' Shuffle the board using rotations, reflections, and token-swapping View Source def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) solve \u00b6 1 2 3 4 def solve ( self , solver : 'Type[Solver]' = < class ' sudoku . solvers . strategy_solver . StrategySolver '> ) -> 'bool' Solve the puzzle using one of the solvers Parameters: Name Type Description Default solver Solver The solver used to solve the puzzle. Defaults to StrategySolver. StrategySolver Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) to_1D \u00b6 1 2 3 def to_1D ( self ) -> 'List[T]' A method for getting back the Sudoku board as a 1-dimensional array Returns: Type Description List[T] A 1D array of the Sudoku board in the board's original type View Source def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] to_2D \u00b6 1 2 3 def to_2D ( self ) -> 'List[List[T]]' A method for getting back the Sudoku board as a 2-dimensional array Returns: Type Description List[T] A 2D array of the Sudoku board in the board's original type View Source def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () to_formatted_string \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def to_formatted_string ( self , cell_corner = '\u253c' , box_corner = '\u256c' , top_left_corner = '\u2554' , top_right_corner = '\u2557' , bottom_left_corner = '\u255a' , bottom_right_corner = '\u255d' , inner_top_tower_corner = '\u2566' , inner_bottom_tower_corner = '\u2569' , inner_left_floor_corner = '\u2560' , inner_right_floor_corner = '\u2563' , cell_horizontal_border = '\u2500' , box_horizontal_border = '\u2550' , cell_vertical_border = '\u2502' , box_vertical_border = '\u2551' , blank = ' ' ) -> 'str' A method for getting back the Sudoku board as a formatted string Returns: Type Description str A formatted string representing the Sudoku board View Source def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str to_string \u00b6 1 2 3 def to_string ( self ) -> 'str' A method for getting back the Sudoku board as a string Returns: Type Description str A string representation in the Sudoku board View Source def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) transpose \u00b6 1 2 3 def transpose ( self ) -> 'None' Switch the rows and columns in the Sudoku board View Source def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i )","title":"Index"},{"location":"reference/sudoku/#module-sudoku","text":"None None View Source from .puzzle import Puzzle __all__ = ( \"Puzzle\" ,)","title":"Module sudoku"},{"location":"reference/sudoku/#sub-modules","text":"sudoku.examples sudoku.puzzle sudoku.solvers sudoku.strategies","title":"Sub-modules"},{"location":"reference/sudoku/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/#puzzle","text":"1 2 3 4 class Puzzle ( puzzle : 'Sequence[T]' , blank : 'T' )","title":"Puzzle"},{"location":"reference/sudoku/#attributes","text":"Name Type Description Default Generic T The base type for each token in the sudoku puzzle None tokens Tokens A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. None order int The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. None cells List[Cell] A list of all the cells in the sudoku puzzle. None View Source class Puzzle ( Generic [ T ] ) : \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ] ) : \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ) : \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ] , self [ j ] = self [ j ] , self [ i ] def shuffle ( self ) : \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1: ] random . shuffle ( tokens ) self [ 1: ] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ] , value : int ) : self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order ) } self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ) : if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order ) } else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ) : r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ) : r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ) : if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank () : yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ) : if not cell . is_blank () : for _ , peer in self . _peers ( i ) : if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ] , blank : T ) : \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ( [ blank ] ) self . cells = np . empty ( len ( puzzle ), dtype = object ). tolist () for i , token in enumerate ( puzzle ) : try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices[0 ] ] for i in range ( 1 , len ( indices )) : self . cells [ indices[i - 1 ] ] = self . cells [ indices[i ] ] self . cells [ indices[-1 ] ] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ) : self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str, int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy.name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy.name ] rating += difficulty * ( eliminations / max_eliminations ) return rating","title":"Attributes"},{"location":"reference/sudoku/#ancestors-in-mro","text":"typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/#class-variables","text":"1 Cell 1 Tokens","title":"Class variables"},{"location":"reference/sudoku/#instance-variables","text":"1 cells 1 order 1 tokens","title":"Instance variables"},{"location":"reference/sudoku/#methods","text":"","title":"Methods"},{"location":"reference/sudoku/#has_conflicts","text":"1 2 3 def has_conflicts ( self ) -> 'bool' A method to determine if the board has any conflicting cells Returns: Type Description bool True if the board has conflicts, False otherwise View Source def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False","title":"has_conflicts"},{"location":"reference/sudoku/#has_solution","text":"1 2 3 def has_solution ( self ) -> 'bool' Check whether the puzzle is able to be solved Returns: Type Description bool A boolean value indicating whether the puzzle has a solution View Source def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve ()","title":"has_solution"},{"location":"reference/sudoku/#is_solved","text":"1 2 3 def is_solved ( self ) -> 'bool' Check whether the puzzle is solved Returns: Type Description bool A boolean value indicating whether the puzzle is solved View Source def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts ()","title":"is_solved"},{"location":"reference/sudoku/#rate","text":"1 2 3 def rate ( self ) -> 'float' Calculate the difficulty of solving the puzzle Returns: Type Description float A difficulty rating between 0 and 1 View Source def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating","title":"rate"},{"location":"reference/sudoku/#reflect","text":"1 2 3 4 def reflect ( self , direction : 'str' = 'horizontal' ) -> 'None' Reflect the Sudoku board horizontally or vertically Parameters: Name Type Description Default direction str The direction over which to reflect. Defaults to \"horizontal\". \"horizontal\" View Source def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j )","title":"reflect"},{"location":"reference/sudoku/#rotate","text":"1 2 3 4 def rotate ( self , rotations = 1 ) -> 'None' Rotate the Sudoku board clockwise a given number in times. Parameters: Name Type Description Default rotations int The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. None View Source def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 )","title":"rotate"},{"location":"reference/sudoku/#shuffle","text":"1 2 3 def shuffle ( self ) -> 'None' Shuffle the board using rotations, reflections, and token-swapping View Source def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 )))","title":"shuffle"},{"location":"reference/sudoku/#solve","text":"1 2 3 4 def solve ( self , solver : 'Type[Solver]' = < class ' sudoku . solvers . strategy_solver . StrategySolver '> ) -> 'bool' Solve the puzzle using one of the solvers Parameters: Name Type Description Default solver Solver The solver used to solve the puzzle. Defaults to StrategySolver. StrategySolver Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self )","title":"solve"},{"location":"reference/sudoku/#to_1d","text":"1 2 3 def to_1D ( self ) -> 'List[T]' A method for getting back the Sudoku board as a 1-dimensional array Returns: Type Description List[T] A 1D array of the Sudoku board in the board's original type View Source def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ]","title":"to_1D"},{"location":"reference/sudoku/#to_2d","text":"1 2 3 def to_2D ( self ) -> 'List[List[T]]' A method for getting back the Sudoku board as a 2-dimensional array Returns: Type Description List[T] A 2D array of the Sudoku board in the board's original type View Source def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist ()","title":"to_2D"},{"location":"reference/sudoku/#to_formatted_string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def to_formatted_string ( self , cell_corner = '\u253c' , box_corner = '\u256c' , top_left_corner = '\u2554' , top_right_corner = '\u2557' , bottom_left_corner = '\u255a' , bottom_right_corner = '\u255d' , inner_top_tower_corner = '\u2566' , inner_bottom_tower_corner = '\u2569' , inner_left_floor_corner = '\u2560' , inner_right_floor_corner = '\u2563' , cell_horizontal_border = '\u2500' , box_horizontal_border = '\u2550' , cell_vertical_border = '\u2502' , box_vertical_border = '\u2551' , blank = ' ' ) -> 'str' A method for getting back the Sudoku board as a formatted string Returns: Type Description str A formatted string representing the Sudoku board View Source def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str","title":"to_formatted_string"},{"location":"reference/sudoku/#to_string","text":"1 2 3 def to_string ( self ) -> 'str' A method for getting back the Sudoku board as a string Returns: Type Description str A string representation in the Sudoku board View Source def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ()))","title":"to_string"},{"location":"reference/sudoku/#transpose","text":"1 2 3 def transpose ( self ) -> 'None' Switch the rows and columns in the Sudoku board View Source def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i )","title":"transpose"},{"location":"reference/sudoku/puzzle/","text":"Module sudoku.puzzle \u00b6 None None View Source from __future__ import annotations import random from collections import defaultdict from copy import deepcopy from typing import Any , DefaultDict , Generic , List , Sequence , Set , Type , TypeVar import numpy as np from .solvers import Solver from .solvers.strategy_solver import StrategySolver , essential_strategies T = TypeVar ( \"T\" , bound = Any ) class Puzzle ( Generic [ T ]): \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ]): \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ): \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ], self [ j ] = self [ j ], self [ i ] def shuffle ( self ): \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1 :] random . shuffle ( tokens ) self [ 1 :] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ], value : int ): self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order )} self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ): if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order )} else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ): boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ): r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ): p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ): row = index // self . order col = index % self . order for i in range ( self . order ): if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ): row = index // self . order col = index % self . order for i in range ( self . order ): if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ): boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ): r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ): p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ): if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank (): yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ], blank : T ): \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ([ blank ]) self . cells = np . empty ( len ( puzzle ), dtype = object ) . tolist () for i , token in enumerate ( puzzle ): try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices [ 0 ]] for i in range ( 1 , len ( indices )): self . cells [ indices [ i - 1 ]] = self . cells [ indices [ i ]] self . cells [ indices [ - 1 ]] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \"horizontal\". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ): for j in range ( x ): self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ): for j in range ( n ): self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ): rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ): for j in range ( i , y - i ): self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ): for j in range ( i + 1 , n ): self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ]: \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self . tokens [ c . value ] for c in self . cells ] def to_2D ( self ) -> List [ List [ T ]]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )) . tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ([ len ( str ( t )) for t in self . tokens ]) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \" { top_border } \\n { box_vertical_border } \" for i , c in enumerate ( self . cells ): v = c . value formatted_str += f \" { self . tokens [ v ] if not c . is_blank () else blank } \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ): formatted_str += f \" { box_vertical_border } \\n { bottom_border } \" else : formatted_str += f \" { box_vertical_border } \\n { floor_border } \\n { box_vertical_border } \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \" { box_vertical_border } \\n { bar_border } \\n { box_vertical_border } \" elif ( i + 1 ) % unit == 0 : formatted_str += f \" { box_vertical_border } \" else : formatted_str += f \" { cell_vertical_border } \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver () . solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ) . solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved (): return 0.0 if self . has_conflicts (): return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved (): changes_made = False for strategy in essential_strategies ( puzzle_copy . order ): eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ): difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating __all__ = ( \"Puzzle\" ,) Classes \u00b6 Puzzle \u00b6 1 2 3 4 class Puzzle ( puzzle : 'Sequence[T]' , blank : 'T' ) Attributes \u00b6 Name Type Description Default Generic T The base type for each token in the sudoku puzzle None tokens Tokens A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. None order int The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. None cells List[Cell] A list of all the cells in the sudoku puzzle. None View Source class Puzzle ( Generic [ T ] ) : \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ] ) : \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ) : \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ] , self [ j ] = self [ j ] , self [ i ] def shuffle ( self ) : \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1: ] random . shuffle ( tokens ) self [ 1: ] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ] , value : int ) : self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order ) } self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ) : if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order ) } else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ) : r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ) : r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ) : if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank () : yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ) : if not cell . is_blank () : for _ , peer in self . _peers ( i ) : if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ] , blank : T ) : \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ( [ blank ] ) self . cells = np . empty ( len ( puzzle ), dtype = object ). tolist () for i , token in enumerate ( puzzle ) : try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices[0 ] ] for i in range ( 1 , len ( indices )) : self . cells [ indices[i - 1 ] ] = self . cells [ indices[i ] ] self . cells [ indices[-1 ] ] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ) : self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str, int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy.name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy.name ] rating += difficulty * ( eliminations / max_eliminations ) return rating Ancestors (in MRO) \u00b6 typing.Generic Class variables \u00b6 1 Cell 1 Tokens Instance variables \u00b6 1 cells 1 order 1 tokens Methods \u00b6 has_conflicts \u00b6 1 2 3 def has_conflicts ( self ) -> 'bool' A method to determine if the board has any conflicting cells Returns: Type Description bool True if the board has conflicts, False otherwise View Source def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False has_solution \u00b6 1 2 3 def has_solution ( self ) -> 'bool' Check whether the puzzle is able to be solved Returns: Type Description bool A boolean value indicating whether the puzzle has a solution View Source def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () is_solved \u00b6 1 2 3 def is_solved ( self ) -> 'bool' Check whether the puzzle is solved Returns: Type Description bool A boolean value indicating whether the puzzle is solved View Source def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () rate \u00b6 1 2 3 def rate ( self ) -> 'float' Calculate the difficulty of solving the puzzle Returns: Type Description float A difficulty rating between 0 and 1 View Source def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating reflect \u00b6 1 2 3 4 def reflect ( self , direction : 'str' = 'horizontal' ) -> 'None' Reflect the Sudoku board horizontally or vertically Parameters: Name Type Description Default direction str The direction over which to reflect. Defaults to \"horizontal\". \"horizontal\" View Source def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) rotate \u00b6 1 2 3 4 def rotate ( self , rotations = 1 ) -> 'None' Rotate the Sudoku board clockwise a given number in times. Parameters: Name Type Description Default rotations int The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. None View Source def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) shuffle \u00b6 1 2 3 def shuffle ( self ) -> 'None' Shuffle the board using rotations, reflections, and token-swapping View Source def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) solve \u00b6 1 2 3 4 def solve ( self , solver : 'Type[Solver]' = < class ' sudoku . solvers . strategy_solver . StrategySolver '> ) -> 'bool' Solve the puzzle using one of the solvers Parameters: Name Type Description Default solver Solver The solver used to solve the puzzle. Defaults to StrategySolver. StrategySolver Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) to_1D \u00b6 1 2 3 def to_1D ( self ) -> 'List[T]' A method for getting back the Sudoku board as a 1-dimensional array Returns: Type Description List[T] A 1D array of the Sudoku board in the board's original type View Source def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] to_2D \u00b6 1 2 3 def to_2D ( self ) -> 'List[List[T]]' A method for getting back the Sudoku board as a 2-dimensional array Returns: Type Description List[T] A 2D array of the Sudoku board in the board's original type View Source def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () to_formatted_string \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def to_formatted_string ( self , cell_corner = '\u253c' , box_corner = '\u256c' , top_left_corner = '\u2554' , top_right_corner = '\u2557' , bottom_left_corner = '\u255a' , bottom_right_corner = '\u255d' , inner_top_tower_corner = '\u2566' , inner_bottom_tower_corner = '\u2569' , inner_left_floor_corner = '\u2560' , inner_right_floor_corner = '\u2563' , cell_horizontal_border = '\u2500' , box_horizontal_border = '\u2550' , cell_vertical_border = '\u2502' , box_vertical_border = '\u2551' , blank = ' ' ) -> 'str' A method for getting back the Sudoku board as a formatted string Returns: Type Description str A formatted string representing the Sudoku board View Source def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str to_string \u00b6 1 2 3 def to_string ( self ) -> 'str' A method for getting back the Sudoku board as a string Returns: Type Description str A string representation in the Sudoku board View Source def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) transpose \u00b6 1 2 3 def transpose ( self ) -> 'None' Switch the rows and columns in the Sudoku board View Source def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i )","title":"Puzzle"},{"location":"reference/sudoku/puzzle/#module-sudokupuzzle","text":"None None View Source from __future__ import annotations import random from collections import defaultdict from copy import deepcopy from typing import Any , DefaultDict , Generic , List , Sequence , Set , Type , TypeVar import numpy as np from .solvers import Solver from .solvers.strategy_solver import StrategySolver , essential_strategies T = TypeVar ( \"T\" , bound = Any ) class Puzzle ( Generic [ T ]): \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ]): \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ): \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ], self [ j ] = self [ j ], self [ i ] def shuffle ( self ): \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1 :] random . shuffle ( tokens ) self [ 1 :] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ], value : int ): self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order )} self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ): if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order )} else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ): boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ): r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ): p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ): row = index // self . order col = index % self . order for i in range ( self . order ): if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ): row = index // self . order col = index % self . order for i in range ( self . order ): if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ): boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ): r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ): p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ): if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank (): yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ], blank : T ): \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ([ blank ]) self . cells = np . empty ( len ( puzzle ), dtype = object ) . tolist () for i , token in enumerate ( puzzle ): try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices [ 0 ]] for i in range ( 1 , len ( indices )): self . cells [ indices [ i - 1 ]] = self . cells [ indices [ i ]] self . cells [ indices [ - 1 ]] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \"horizontal\". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ): for j in range ( x ): self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ): for j in range ( n ): self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ): rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ): for j in range ( i , y - i ): self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ): for j in range ( i + 1 , n ): self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ]: \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self . tokens [ c . value ] for c in self . cells ] def to_2D ( self ) -> List [ List [ T ]]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )) . tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ([ len ( str ( t )) for t in self . tokens ]) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \" { top_border } \\n { box_vertical_border } \" for i , c in enumerate ( self . cells ): v = c . value formatted_str += f \" { self . tokens [ v ] if not c . is_blank () else blank } \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ): formatted_str += f \" { box_vertical_border } \\n { bottom_border } \" else : formatted_str += f \" { box_vertical_border } \\n { floor_border } \\n { box_vertical_border } \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \" { box_vertical_border } \\n { bar_border } \\n { box_vertical_border } \" elif ( i + 1 ) % unit == 0 : formatted_str += f \" { box_vertical_border } \" else : formatted_str += f \" { cell_vertical_border } \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver () . solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ) . solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved (): return 0.0 if self . has_conflicts (): return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved (): changes_made = False for strategy in essential_strategies ( puzzle_copy . order ): eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ): difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating __all__ = ( \"Puzzle\" ,)","title":"Module sudoku.puzzle"},{"location":"reference/sudoku/puzzle/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/puzzle/#puzzle","text":"1 2 3 4 class Puzzle ( puzzle : 'Sequence[T]' , blank : 'T' )","title":"Puzzle"},{"location":"reference/sudoku/puzzle/#attributes","text":"Name Type Description Default Generic T The base type for each token in the sudoku puzzle None tokens Tokens A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. None order int The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. None cells List[Cell] A list of all the cells in the sudoku puzzle. None View Source class Puzzle ( Generic [ T ] ) : \"\"\" The base class for a sudoku puzzle. ``` Args: Generic (T): The base type for each token in the sudoku puzzle Attributes: tokens (Tokens): A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. order (int): The number of unique tokens in use in the puzzle. For the common 9x9 sudoku puzzle, this value is 9. cells (List[Cell]): A list of all the cells in the sudoku puzzle. \"\"\" __slots__ = \"order\" , \"tokens\" , \"cells\" order : int tokens : Tokens cells : List [ Cell ] class Tokens ( List [ T ] ) : \"\"\" A list of the tokens in use in the sudoku puzzle as identified by their integer aliases, which are the respective indices of this list. \"\"\" def swap ( self , i : int , j : int ) : \"\"\" Switch the positions of two sets of tokens in the puzzle by switching their respective aliases. Args: i (int): The integer alias value associated with a token j (int): The integer alias value associated with a token \"\"\" self [ i ] , self [ j ] = self [ j ] , self [ i ] def shuffle ( self ) : \"\"\" Randomly swap the tokens in the puzzle by randomizing their integer aliases. \"\"\" tokens = self [ 1: ] random . shuffle ( tokens ) self [ 1: ] = tokens class Cell : \"\"\" The class for an individual cell in the sudoku puzzle Attributes: puzzle (Puzzle): The corresponding sudoku puzzle candidates (Set[int]): A set of the cell's remaining candidates value (int): The value of the sudoku cell or 0 if it is blank. \"\"\" __slots__ = \"puzzle\" , \"candidates\" puzzle : Puzzle candidates : Set [ int ] def __init__ ( self , puzzle : Puzzle [ T ] , value : int ) : self . puzzle = puzzle self . candidates = { i + 1 for i in range ( self . puzzle . order ) } self . value = value @property def value ( self ) -> int : if len ( self . candidates ) > 1 : return 0 return next ( iter ( self . candidates )) @value . setter def value ( self , value : int ) : if value == 0 : self . candidates = { i + 1 for i in range ( self . puzzle . order ) } else : self . candidates = { value } def is_blank ( self ) -> bool : \"\"\" Check whether the cell is blank or has a value. Returns: bool: A boolean value for whether the cell is blank. \"\"\" return len ( self . candidates ) > 1 def _box ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeRow = boxWidth * ( row // boxWidth ) edgeCol = boxWidth * ( col // boxWidth ) for i in range ( self . order ) : r = edgeRow + i // boxWidth c = edgeCol + ( i % boxWidth ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) yield p , self . cells [ p ] def _row ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != col : p = int ( self . order * row + i ) yield p , self . cells [ p ] def _col ( self , index : int ) : row = index // self . order col = index % self . order for i in range ( self . order ) : if i != row : p = int ( self . order * i + col ) yield p , self . cells [ p ] def _peers ( self , index : int ) : boxWidth = int ( self . order ** 0.5 ) row = index // self . order col = index % self . order edgeM = boxWidth * ( row // boxWidth ) edgeN = boxWidth * ( col // boxWidth ) peers = set () for i in range ( self . order ) : r = edgeM + i // boxWidth c = edgeN + i % boxWidth if i != col : p = int ( self . order * row + i ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if i != row : p = int ( self . order * i + col ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) if not ( r == row and c == col ) : p = int ( self . order * r + c ) if p not in peers : yield p , self . cells [ p ] peers . add ( p ) def _blank ( self , indices = None ) : if indices is None : indices = range ( self . order ** 2 ) for i in indices : cell = self . cells [ i ] if cell . is_blank () : yield i , cell def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ) : if not cell . is_blank () : for _ , peer in self . _peers ( i ) : if not peer . is_blank () and cell . value == peer . value : return True return False def __init__ ( self , puzzle : Sequence [ T ] , blank : T ) : \"\"\" The object can be constructed with any 1-dimensional iterable: ```python arr_1d = [1, 0, 3, 4, 0, 4, 1, 0, 0, 3, 0, 1, 4, 0, 2, 3] puzzle = Puzzle(arr_1d, 0) ``` Args: puzzle (Sequence[T]): A sequence representing a Sudoku puzzle blank (T): The value used to represent a blank cell \"\"\" self . order = int ( len ( puzzle ) ** 0.5 ) self . tokens = self . Tokens ( [ blank ] ) self . cells = np . empty ( len ( puzzle ), dtype = object ). tolist () for i , token in enumerate ( puzzle ) : try : v = self . tokens . index ( token ) except ValueError : self . tokens . append ( token ) v = len ( self . tokens ) - 1 self . cells [ i ] = self . Cell ( self , v ) def _shift_indices ( self , * indices : int ) -> None : tmp = self . cells [ indices[0 ] ] for i in range ( 1 , len ( indices )) : self . cells [ indices[i - 1 ] ] = self . cells [ indices[i ] ] self . cells [ indices[-1 ] ] = tmp def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j ) def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 ) def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i ) def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2 ) : self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 ))) def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ] def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist () def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ())) def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts () def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self ) def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve () def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str, int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy.name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy.name ] rating += difficulty * ( eliminations / max_eliminations ) return rating","title":"Attributes"},{"location":"reference/sudoku/puzzle/#ancestors-in-mro","text":"typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/puzzle/#class-variables","text":"1 Cell 1 Tokens","title":"Class variables"},{"location":"reference/sudoku/puzzle/#instance-variables","text":"1 cells 1 order 1 tokens","title":"Instance variables"},{"location":"reference/sudoku/puzzle/#methods","text":"","title":"Methods"},{"location":"reference/sudoku/puzzle/#has_conflicts","text":"1 2 3 def has_conflicts ( self ) -> 'bool' A method to determine if the board has any conflicting cells Returns: Type Description bool True if the board has conflicts, False otherwise View Source def has_conflicts ( self ) -> bool : \"\"\" A method to determine if the board has any conflicting cells Returns: bool: True if the board has conflicts, False otherwise \"\"\" for i , cell in enumerate ( self . cells ): if not cell . is_blank (): for _ , peer in self . _peers ( i ): if not peer . is_blank () and cell . value == peer . value : return True return False","title":"has_conflicts"},{"location":"reference/sudoku/puzzle/#has_solution","text":"1 2 3 def has_solution ( self ) -> 'bool' Check whether the puzzle is able to be solved Returns: Type Description bool A boolean value indicating whether the puzzle has a solution View Source def has_solution ( self ) -> bool : \"\"\" Check whether the puzzle is able to be solved Returns: bool: A boolean value indicating whether the puzzle has a solution \"\"\" return deepcopy ( self ). solve ()","title":"has_solution"},{"location":"reference/sudoku/puzzle/#is_solved","text":"1 2 3 def is_solved ( self ) -> 'bool' Check whether the puzzle is solved Returns: Type Description bool A boolean value indicating whether the puzzle is solved View Source def is_solved ( self ) -> bool : \"\"\" Check whether the puzzle is solved Returns: bool: A boolean value indicating whether the puzzle is solved \"\"\" return not any ( c . is_blank () for c in self . cells ) and not self . has_conflicts ()","title":"is_solved"},{"location":"reference/sudoku/puzzle/#rate","text":"1 2 3 def rate ( self ) -> 'float' Calculate the difficulty of solving the puzzle Returns: Type Description float A difficulty rating between 0 and 1 View Source def rate ( self ) -> float : \"\"\" Calculate the difficulty of solving the puzzle Returns: float: A difficulty rating between 0 and 1 \"\"\" if self . is_solved () : return 0.0 if self . has_conflicts () : return 1.0 strategy_eliminations : DefaultDict [ str , int ] = defaultdict ( int ) puzzle_copy = deepcopy ( self ) while not puzzle_copy . is_solved () : changes_made = False for strategy in essential_strategies ( puzzle_copy . order ) : eliminations = strategy ( puzzle_copy ) strategy_eliminations [ strategy . name ] += eliminations if eliminations > 0 : changes_made = True break if not changes_made : return 1.0 max_eliminations = self . order ** 3 - self . order ** 2 rating = 0.0 for strategy in essential_strategies ( self . order ) : difficulty = strategy . difficulty eliminations = strategy_eliminations [ strategy . name ] rating += difficulty * ( eliminations / max_eliminations ) return rating","title":"rate"},{"location":"reference/sudoku/puzzle/#reflect","text":"1 2 3 4 def reflect ( self , direction : 'str' = 'horizontal' ) -> 'None' Reflect the Sudoku board horizontally or vertically Parameters: Name Type Description Default direction str The direction over which to reflect. Defaults to \"horizontal\". \"horizontal\" View Source def reflect ( self , direction : str = \"horizontal\" ) -> None : \"\"\" Reflect the Sudoku board horizontally or vertically Args: direction (str): The direction over which to reflect. Defaults to \" horizontal \". \"\"\" n = self . order x = n // 2 y = n - 1 if direction == \"horizontal\" : for i in range ( n ) : for j in range ( x ) : self . _shift_indices ( n * i + j , n * i + ( y - j )) else : for i in range ( x ) : for j in range ( n ) : self . _shift_indices ( n * i + j , n * ( y - i ) + j )","title":"reflect"},{"location":"reference/sudoku/puzzle/#rotate","text":"1 2 3 4 def rotate ( self , rotations = 1 ) -> 'None' Rotate the Sudoku board clockwise a given number in times. Parameters: Name Type Description Default rotations int The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. None View Source def rotate ( self , rotations = 1 ) -> None : \"\"\" Rotate the Sudoku board clockwise a given number in times. Args: rotations (int): The number in clockwise rotations to be performed. This value may be negative and is rounded to the nearest integer. Defaults to 1. \"\"\" if not isinstance ( rotations , int ) : rotations = round ( rotations ) if rotations % 4 == 0 : return elif rotations % 2 == 0 : self . cells = np . flip ( self . cells ) return elif rotations < 0 : self . rotate ( - 1 * rotations + 2 ) else : n = self . order x = n // 2 y = n - 1 for i in range ( x ) : for j in range ( i , y - i ) : self . _shift_indices ( n * i + j , n * ( y - j ) + i , n * ( y - i ) + y - j , n * j + y - i ) self . rotate ( rotations - 1 )","title":"rotate"},{"location":"reference/sudoku/puzzle/#shuffle","text":"1 2 3 def shuffle ( self ) -> 'None' Shuffle the board using rotations, reflections, and token-swapping View Source def shuffle ( self ) -> None : \"\"\" Shuffle the board using rotations, reflections, and token-swapping \"\"\" self . tokens . shuffle () for _ in range ( self . order // 2): self . reflect ( random . choice (( \"horizontal\" , \"vertical\" ))) self . rotate ( random . choice ( range ( 4 )))","title":"shuffle"},{"location":"reference/sudoku/puzzle/#solve","text":"1 2 3 4 def solve ( self , solver : 'Type[Solver]' = < class ' sudoku . solvers . strategy_solver . StrategySolver '> ) -> 'bool' Solve the puzzle using one of the solvers Parameters: Name Type Description Default solver Solver The solver used to solve the puzzle. Defaults to StrategySolver. StrategySolver Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , solver : Type [ Solver ] = StrategySolver ) -> bool : \"\"\" Solve the puzzle using one of the solvers Args: solver (Solver, optional): The solver used to solve the puzzle. Defaults to StrategySolver. Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" return solver (). solve ( self )","title":"solve"},{"location":"reference/sudoku/puzzle/#to_1d","text":"1 2 3 def to_1D ( self ) -> 'List[T]' A method for getting back the Sudoku board as a 1-dimensional array Returns: Type Description List[T] A 1D array of the Sudoku board in the board's original type View Source def to_1D ( self ) -> List [ T ] : \"\"\" A method for getting back the Sudoku board as a 1-dimensional array Returns: List[T]: A 1D array of the Sudoku board in the board's original type \"\"\" return [ self.tokens[c.value ] for c in self . cells ]","title":"to_1D"},{"location":"reference/sudoku/puzzle/#to_2d","text":"1 2 3 def to_2D ( self ) -> 'List[List[T]]' A method for getting back the Sudoku board as a 2-dimensional array Returns: Type Description List[T] A 2D array of the Sudoku board in the board's original type View Source def to_2D ( self ) -> List [ List[T ] ]: \"\"\" A method for getting back the Sudoku board as a 2-dimensional array Returns: List[T]: A 2D array of the Sudoku board in the board's original type \"\"\" return np . reshape ( self . to_1D (), ( self . order , self . order )). tolist ()","title":"to_2D"},{"location":"reference/sudoku/puzzle/#to_formatted_string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def to_formatted_string ( self , cell_corner = '\u253c' , box_corner = '\u256c' , top_left_corner = '\u2554' , top_right_corner = '\u2557' , bottom_left_corner = '\u255a' , bottom_right_corner = '\u255d' , inner_top_tower_corner = '\u2566' , inner_bottom_tower_corner = '\u2569' , inner_left_floor_corner = '\u2560' , inner_right_floor_corner = '\u2563' , cell_horizontal_border = '\u2500' , box_horizontal_border = '\u2550' , cell_vertical_border = '\u2502' , box_vertical_border = '\u2551' , blank = ' ' ) -> 'str' A method for getting back the Sudoku board as a formatted string Returns: Type Description str A formatted string representing the Sudoku board View Source def to_formatted_string ( self , cell_corner = \"\u253c\" , box_corner = \"\u256c\" , top_left_corner = \"\u2554\" , top_right_corner = \"\u2557\" , bottom_left_corner = \"\u255a\" , bottom_right_corner = \"\u255d\" , inner_top_tower_corner = \"\u2566\" , inner_bottom_tower_corner = \"\u2569\" , inner_left_floor_corner = \"\u2560\" , inner_right_floor_corner = \"\u2563\" , cell_horizontal_border = \"\u2500\" , box_horizontal_border = \"\u2550\" , cell_vertical_border = \"\u2502\" , box_vertical_border = \"\u2551\" , blank = \" \" , ) -> str : \"\"\" A method for getting back the Sudoku board as a formatted string Returns: str: A formatted string representing the Sudoku board \"\"\" unit = int ( self . order ** 0.5 ) token_width = max ( [ len(str(t)) for t in self.tokens ] ) cell_width = token_width + 2 box_width = unit * ( cell_width + 1 ) - 1 top_border = ( top_left_corner + box_horizontal_border * ( box_width ) + ( inner_top_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + top_right_corner ) bottom_border = ( bottom_left_corner + box_horizontal_border * ( box_width ) + ( inner_bottom_tower_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + bottom_right_corner ) floor_border = ( inner_left_floor_corner + box_horizontal_border * ( box_width ) + ( box_corner + box_horizontal_border * ( box_width )) * ( unit - 1 ) + inner_right_floor_corner ) bar_border = ( box_vertical_border + cell_horizontal_border * ( cell_width ) + ( cell_corner + cell_horizontal_border * ( cell_width )) * ( unit - 1 ) ) * ( unit ) + box_vertical_border formatted_str = f \"{top_border}\\n{box_vertical_border} \" for i , c in enumerate ( self . cells ) : v = c . value formatted_str += f \"{self.tokens[v] if not c.is_blank() else blank} \" if ( i + 1 ) % ( self . order * unit ) == 0 : if i + 1 == len ( self . cells ) : formatted_str += f \"{box_vertical_border}\\n{bottom_border}\" else : formatted_str += f \"{box_vertical_border}\\n{floor_border}\\n{box_vertical_border} \" elif ( i + 1 ) % self . order == 0 : formatted_str += f \"{box_vertical_border}\\n{bar_border}\\n{box_vertical_border} \" elif ( i + 1 ) % unit == 0 : formatted_str += f \"{box_vertical_border} \" else : formatted_str += f \"{cell_vertical_border} \" return formatted_str","title":"to_formatted_string"},{"location":"reference/sudoku/puzzle/#to_string","text":"1 2 3 def to_string ( self ) -> 'str' A method for getting back the Sudoku board as a string Returns: Type Description str A string representation in the Sudoku board View Source def to_string ( self ) -> str : \"\"\" A method for getting back the Sudoku board as a string Returns: str: A string representation in the Sudoku board \"\"\" return \"\" . join (( str ( c ) for c in self . to_1D ()))","title":"to_string"},{"location":"reference/sudoku/puzzle/#transpose","text":"1 2 3 def transpose ( self ) -> 'None' Switch the rows and columns in the Sudoku board View Source def transpose ( self ) -> None : \"\"\" Switch the rows and columns in the Sudoku board \"\"\" n = self . order for i in range ( n ) : for j in range ( i + 1 , n ) : self . _shift_indices ( n * i + j , n * j + i )","title":"transpose"},{"location":"reference/sudoku/examples/","text":"Module sudoku.examples \u00b6 None None View Source from .boards import boards __all__ = [ \"boards\" ] Sub-modules \u00b6 sudoku.examples.boards sudoku.examples.rate sudoku.examples.shuffle sudoku.examples.solve Variables \u00b6 1 boards","title":"Index"},{"location":"reference/sudoku/examples/#module-sudokuexamples","text":"None None View Source from .boards import boards __all__ = [ \"boards\" ]","title":"Module sudoku.examples"},{"location":"reference/sudoku/examples/#sub-modules","text":"sudoku.examples.boards sudoku.examples.rate sudoku.examples.shuffle sudoku.examples.solve","title":"Sub-modules"},{"location":"reference/sudoku/examples/#variables","text":"1 boards","title":"Variables"},{"location":"reference/sudoku/examples/boards/","text":"Module sudoku.examples.boards \u00b6 None None View Source boards = [ \"...1.5...14....67..8...24...63.7..1.9.......3.1..9.52...72...8..26....35...4.9...\", \".234.6789.567.9123.891.3456.345.7891.678.1234.912.4567.456.8912.789.2345.123.5678\", \"32.41.3..14.43.1\", \"1.34.41..3.14.23\", \".....4.284.6.....51...3.6.....3.1....87...14....7.9.....2.1...39.....5.767.4.....\", \"72..96..3...2.5....8...4.2........6.1.65.38.7.4........3.8...9....7.2...2..43..18\", ] Variables \u00b6 1 boards","title":"Boards"},{"location":"reference/sudoku/examples/boards/#module-sudokuexamplesboards","text":"None None View Source boards = [ \"...1.5...14....67..8...24...63.7..1.9.......3.1..9.52...72...8..26....35...4.9...\", \".234.6789.567.9123.891.3456.345.7891.678.1234.912.4567.456.8912.789.2345.123.5678\", \"32.41.3..14.43.1\", \"1.34.41..3.14.23\", \".....4.284.6.....51...3.6.....3.1....87...14....7.9.....2.1...39.....5.767.4.....\", \"72..96..3...2.5....8...4.2........6.1.65.38.7.4........3.8...9....7.2...2..43..18\", ]","title":"Module sudoku.examples.boards"},{"location":"reference/sudoku/examples/boards/#variables","text":"1 boards","title":"Variables"},{"location":"reference/sudoku/examples/rate/","text":"Module sudoku.examples.rate \u00b6 None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) print ( f \"Rating: { puzzle . rate () } \" ) Variables \u00b6 1 boards","title":"Rate"},{"location":"reference/sudoku/examples/rate/#module-sudokuexamplesrate","text":"None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) print ( f \"Rating: { puzzle . rate () } \" )","title":"Module sudoku.examples.rate"},{"location":"reference/sudoku/examples/rate/#variables","text":"1 boards","title":"Variables"},{"location":"reference/sudoku/examples/shuffle/","text":"Module sudoku.examples.shuffle \u00b6 None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) puzzle . shuffle () print ( f \"Shuffled: \\n { puzzle . to_formatted_string () } \" ) Variables \u00b6 1 boards","title":"Shuffle"},{"location":"reference/sudoku/examples/shuffle/#module-sudokuexamplesshuffle","text":"None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) puzzle . shuffle () print ( f \"Shuffled: \\n { puzzle . to_formatted_string () } \" )","title":"Module sudoku.examples.shuffle"},{"location":"reference/sudoku/examples/shuffle/#variables","text":"1 boards","title":"Variables"},{"location":"reference/sudoku/examples/solve/","text":"Module sudoku.examples.solve \u00b6 None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) candidate_eliminations = puzzle . solve () print ( f \"Solution: \\n { puzzle . to_formatted_string () } \" ) print ( candidate_eliminations ) Variables \u00b6 1 boards","title":"Solve"},{"location":"reference/sudoku/examples/solve/#module-sudokuexamplessolve","text":"None None View Source from .. import Puzzle from .boards import boards if __name__ == \"__main__\" : for i , board in enumerate ( boards ): print ( f \"Board { i } : { board } \" ) puzzle = Puzzle ( board , \".\" ) print ( f \"Puzzle { i } : \\n { puzzle . to_formatted_string () } \" ) candidate_eliminations = puzzle . solve () print ( f \"Solution: \\n { puzzle . to_formatted_string () } \" ) print ( candidate_eliminations )","title":"Module sudoku.examples.solve"},{"location":"reference/sudoku/examples/solve/#variables","text":"1 boards","title":"Variables"},{"location":"reference/sudoku/solvers/","text":"Module sudoku.solvers \u00b6 None None View Source from .solver import Solver from .strategy_solver import StrategySolver __all__ = ( \"Solver\" , \"StrategySolver\" ) Sub-modules \u00b6 sudoku.solvers.solver sudoku.solvers.strategy_solver Classes \u00b6 Solver \u00b6 1 2 3 4 5 class Solver ( / , * args , ** kwargs ) View Source class Solver ( ABC ) : @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ... Ancestors (in MRO) \u00b6 abc.ABC Descendants \u00b6 sudoku.solvers.StrategySolver Methods \u00b6 solve \u00b6 1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle in place. Parameters: Name Type Description Default puzzle Puzzle The puzzle to be solved. None Returns: Type Description bool Whether or not the puzzle is solved. View Source @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ... StrategySolver \u00b6 1 2 3 4 5 class StrategySolver ( / , * args , ** kwargs ) View Source class StrategySolver ( Solver ) : def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True Ancestors (in MRO) \u00b6 sudoku.solvers.Solver abc.ABC Methods \u00b6 solve \u00b6 1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle using strategies Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"Index"},{"location":"reference/sudoku/solvers/#module-sudokusolvers","text":"None None View Source from .solver import Solver from .strategy_solver import StrategySolver __all__ = ( \"Solver\" , \"StrategySolver\" )","title":"Module sudoku.solvers"},{"location":"reference/sudoku/solvers/#sub-modules","text":"sudoku.solvers.solver sudoku.solvers.strategy_solver","title":"Sub-modules"},{"location":"reference/sudoku/solvers/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/solvers/#solver","text":"1 2 3 4 5 class Solver ( / , * args , ** kwargs ) View Source class Solver ( ABC ) : @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ...","title":"Solver"},{"location":"reference/sudoku/solvers/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/solvers/#descendants","text":"sudoku.solvers.StrategySolver","title":"Descendants"},{"location":"reference/sudoku/solvers/#methods","text":"","title":"Methods"},{"location":"reference/sudoku/solvers/#solve","text":"1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle in place. Parameters: Name Type Description Default puzzle Puzzle The puzzle to be solved. None Returns: Type Description bool Whether or not the puzzle is solved. View Source @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ...","title":"solve"},{"location":"reference/sudoku/solvers/#strategysolver","text":"1 2 3 4 5 class StrategySolver ( / , * args , ** kwargs ) View Source class StrategySolver ( Solver ) : def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"StrategySolver"},{"location":"reference/sudoku/solvers/#ancestors-in-mro_1","text":"sudoku.solvers.Solver abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/solvers/#methods_1","text":"","title":"Methods"},{"location":"reference/sudoku/solvers/#solve_1","text":"1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle using strategies Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"solve"},{"location":"reference/sudoku/solvers/solver/","text":"Module sudoku.solvers.solver \u00b6 None None View Source from __future__ import annotations from abc import ABC , abstractmethod from typing import TYPE_CHECKING if TYPE_CHECKING : from ..puzzle import Puzzle , T class Solver ( ABC ): @abstractmethod def solve ( self , puzzle : Puzzle [ T ]) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ... __all__ = ( \"Solver\" ,) Classes \u00b6 Solver \u00b6 1 2 3 4 5 class Solver ( / , * args , ** kwargs ) View Source class Solver ( ABC ) : @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ... Ancestors (in MRO) \u00b6 abc.ABC Descendants \u00b6 sudoku.solvers.strategy_solver.StrategySolver Methods \u00b6 solve \u00b6 1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle in place. Parameters: Name Type Description Default puzzle Puzzle The puzzle to be solved. None Returns: Type Description bool Whether or not the puzzle is solved. View Source @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ...","title":"Solver"},{"location":"reference/sudoku/solvers/solver/#module-sudokusolverssolver","text":"None None View Source from __future__ import annotations from abc import ABC , abstractmethod from typing import TYPE_CHECKING if TYPE_CHECKING : from ..puzzle import Puzzle , T class Solver ( ABC ): @abstractmethod def solve ( self , puzzle : Puzzle [ T ]) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ... __all__ = ( \"Solver\" ,)","title":"Module sudoku.solvers.solver"},{"location":"reference/sudoku/solvers/solver/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/solvers/solver/#solver","text":"1 2 3 4 5 class Solver ( / , * args , ** kwargs ) View Source class Solver ( ABC ) : @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ...","title":"Solver"},{"location":"reference/sudoku/solvers/solver/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/solvers/solver/#descendants","text":"sudoku.solvers.strategy_solver.StrategySolver","title":"Descendants"},{"location":"reference/sudoku/solvers/solver/#methods","text":"","title":"Methods"},{"location":"reference/sudoku/solvers/solver/#solve","text":"1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle in place. Parameters: Name Type Description Default puzzle Puzzle The puzzle to be solved. None Returns: Type Description bool Whether or not the puzzle is solved. View Source @abstractmethod def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\"Solve the puzzle in place. Args: puzzle (Puzzle): The puzzle to be solved. Returns: bool: Whether or not the puzzle is solved. \"\"\" ...","title":"solve"},{"location":"reference/sudoku/solvers/strategy_solver/","text":"Module sudoku.solvers.strategy_solver \u00b6 None None View Source from __future__ import annotations from typing import TYPE_CHECKING , Generator from ..strategies import HiddenSubset , NakedSubset , RefreshCandidates , Strategy from .solver import Solver if TYPE_CHECKING : from ..puzzle import Puzzle , T def essential_strategies ( order : int ) -> Generator [ Strategy , None , None ]: \"\"\" Generator for strategies from simple to complex with a given order \"\"\" yield RefreshCandidates () for s in range ( 1 , order // 2 ): yield NakedSubset ( s ) yield HiddenSubset ( s ) class StrategySolver ( Solver ): def solve ( self , puzzle : Puzzle [ T ]) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts (): return False while not puzzle . is_solved (): changed = False for strategy in essential_strategies ( puzzle . order ): if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True __all__ = ( \"StrategySolver\" , \"essential_strategies\" ) Functions \u00b6 essential_strategies \u00b6 1 2 3 def essential_strategies ( order : 'int' ) -> 'Generator[Strategy, None, None]' Generator for strategies from simple to complex with a given order View Source def essential_strategies ( order : int ) -> Generator [ Strategy , None , None ] : \"\"\" Generator for strategies from simple to complex with a given order \"\"\" yield RefreshCandidates () for s in range ( 1 , order // 2): yield NakedSubset ( s ) yield HiddenSubset ( s ) Classes \u00b6 StrategySolver \u00b6 1 2 3 4 5 class StrategySolver ( / , * args , ** kwargs ) View Source class StrategySolver ( Solver ) : def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True Ancestors (in MRO) \u00b6 sudoku.solvers.solver.Solver abc.ABC Methods \u00b6 solve \u00b6 1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle using strategies Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"Strategy Solver"},{"location":"reference/sudoku/solvers/strategy_solver/#module-sudokusolversstrategy_solver","text":"None None View Source from __future__ import annotations from typing import TYPE_CHECKING , Generator from ..strategies import HiddenSubset , NakedSubset , RefreshCandidates , Strategy from .solver import Solver if TYPE_CHECKING : from ..puzzle import Puzzle , T def essential_strategies ( order : int ) -> Generator [ Strategy , None , None ]: \"\"\" Generator for strategies from simple to complex with a given order \"\"\" yield RefreshCandidates () for s in range ( 1 , order // 2 ): yield NakedSubset ( s ) yield HiddenSubset ( s ) class StrategySolver ( Solver ): def solve ( self , puzzle : Puzzle [ T ]) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts (): return False while not puzzle . is_solved (): changed = False for strategy in essential_strategies ( puzzle . order ): if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True __all__ = ( \"StrategySolver\" , \"essential_strategies\" )","title":"Module sudoku.solvers.strategy_solver"},{"location":"reference/sudoku/solvers/strategy_solver/#functions","text":"","title":"Functions"},{"location":"reference/sudoku/solvers/strategy_solver/#essential_strategies","text":"1 2 3 def essential_strategies ( order : 'int' ) -> 'Generator[Strategy, None, None]' Generator for strategies from simple to complex with a given order View Source def essential_strategies ( order : int ) -> Generator [ Strategy , None , None ] : \"\"\" Generator for strategies from simple to complex with a given order \"\"\" yield RefreshCandidates () for s in range ( 1 , order // 2): yield NakedSubset ( s ) yield HiddenSubset ( s )","title":"essential_strategies"},{"location":"reference/sudoku/solvers/strategy_solver/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/solvers/strategy_solver/#strategysolver","text":"1 2 3 4 5 class StrategySolver ( / , * args , ** kwargs ) View Source class StrategySolver ( Solver ) : def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"StrategySolver"},{"location":"reference/sudoku/solvers/strategy_solver/#ancestors-in-mro","text":"sudoku.solvers.solver.Solver abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/solvers/strategy_solver/#methods","text":"","title":"Methods"},{"location":"reference/sudoku/solvers/strategy_solver/#solve","text":"1 2 3 4 def solve ( self , puzzle : 'Puzzle[T]' ) -> 'bool' Solve the puzzle using strategies Returns: Type Description bool A boolean value indicating whether the puzzle could be solved View Source def solve ( self , puzzle : Puzzle [ T ] ) -> bool : \"\"\" Solve the puzzle using strategies Returns: bool: A boolean value indicating whether the puzzle could be solved \"\"\" if puzzle . has_conflicts () : return False while not puzzle . is_solved () : changed = False for strategy in essential_strategies ( puzzle . order ) : if strategy ( puzzle ) > 0 : changed = True break if not changed : return False return True","title":"solve"},{"location":"reference/sudoku/strategies/","text":"Module sudoku.strategies \u00b6 None None View Source from .hidden_subset import HiddenSingle , HiddenSubset , PinnedDigit from .naked_subset import ForcedDigit , NakedDouble , NakedQuad , NakedSingle , NakedSubset , NakedTriple from .refresh_candidates import RefreshCandidates from .strategy import Strategy __all__ = ( \"Strategy\" , \"RefreshCandidates\" , \"HiddenSubset\" , \"HiddenSingle\" , \"PinnedDigit\" , \"ForcedDigit\" , \"NakedDouble\" , \"NakedQuad\" , \"NakedSingle\" , \"NakedSubset\" , \"NakedTriple\" , ) Sub-modules \u00b6 sudoku.strategies.hidden_subset sudoku.strategies.naked_subset sudoku.strategies.refresh_candidates sudoku.strategies.strategy Classes \u00b6 ForcedDigit \u00b6 1 2 3 class ForcedDigit ( ) View Source class ForcedDigit ( NakedSingle ) : \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" Ancestors (in MRO) \u00b6 sudoku.strategies.NakedSingle sudoku.strategies.NakedSubset sudoku.strategies.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size HiddenSingle \u00b6 1 2 3 class HiddenSingle ( ) View Source class HiddenSingle ( HiddenSubset ) : \"\"\" The [ Hidden Single ]( http : //sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 ) Ancestors (in MRO) \u00b6 sudoku.strategies.HiddenSubset sudoku.strategies.Strategy Descendants \u00b6 sudoku.strategies.PinnedDigit Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size HiddenSubset \u00b6 1 2 3 class HiddenSubset ( size ) View Source class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.Strategy Descendants \u00b6 sudoku.strategies.HiddenSingle Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size NakedDouble \u00b6 1 2 3 class NakedDouble ( ) View Source class NakedDouble ( NakedSubset ) : \"\"\" Apply the [ Naked Double ]( http : //sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 2 ) Ancestors (in MRO) \u00b6 sudoku.strategies.NakedSubset sudoku.strategies.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size NakedQuad \u00b6 1 2 3 class NakedQuad ( ) View Source class NakedQuad ( NakedSubset ) : \"\"\" Apply the [ Naked Quad ]( http : //sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 4 ) Ancestors (in MRO) \u00b6 sudoku.strategies.NakedSubset sudoku.strategies.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size NakedSingle \u00b6 1 2 3 class NakedSingle ( ) View Source class NakedSingle ( NakedSubset ) : \"\"\" The [ Naked Single ]( http : //sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 ) Ancestors (in MRO) \u00b6 sudoku.strategies.NakedSubset sudoku.strategies.Strategy Descendants \u00b6 sudoku.strategies.ForcedDigit sudoku.strategies.naked_subset.SoleCandidate Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size NakedSubset \u00b6 1 2 3 class NakedSubset ( size : 'int' ) View Source class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.Strategy Descendants \u00b6 sudoku.strategies.NakedSingle sudoku.strategies.NakedDouble sudoku.strategies.NakedTriple sudoku.strategies.NakedQuad Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size NakedTriple \u00b6 1 2 3 class NakedTriple ( ) View Source class NakedTriple ( NakedSubset ) : \"\"\" Apply the [ Naked Triple ]( http : //sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 3 ) Ancestors (in MRO) \u00b6 sudoku.strategies.NakedSubset sudoku.strategies.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size PinnedDigit \u00b6 1 2 3 class PinnedDigit ( ) View Source class PinnedDigit ( HiddenSingle ) : \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\" Ancestors (in MRO) \u00b6 sudoku.strategies.HiddenSingle sudoku.strategies.HiddenSubset sudoku.strategies.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 difficulty 1 name 1 size RefreshCandidates \u00b6 1 2 3 class RefreshCandidates ( ) View Source class RefreshCandidates ( Strategy ) : \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ) : super (). __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ] ) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ) : for _ , peer in puzzle . _peers ( i ) : if cell . is_blank () and not peer . is_blank () : if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.Strategy Instance variables \u00b6 1 difficulty 1 name Strategy \u00b6 1 2 3 4 class Strategy ( name = None , difficulty = None ) Attributes \u00b6 Name Type Description Default name str The name of the strategy None difficulty float The difficulty rating of the strategy defined with respect to eliminating a single candidate None View Source class Strategy : \"\"\" Also known as a [ Solving Technique ]( http : //sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes : name ( str ) : The name of the strategy difficulty ( float ) : The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ) : self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args : puzzle ( Puzzle [ T ]) : The sudoku puzzle Returns : int : The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\" Descendants \u00b6 sudoku.strategies.HiddenSubset sudoku.strategies.NakedSubset sudoku.strategies.RefreshCandidates Instance variables \u00b6 1 difficulty 1 name","title":"Index"},{"location":"reference/sudoku/strategies/#module-sudokustrategies","text":"None None View Source from .hidden_subset import HiddenSingle , HiddenSubset , PinnedDigit from .naked_subset import ForcedDigit , NakedDouble , NakedQuad , NakedSingle , NakedSubset , NakedTriple from .refresh_candidates import RefreshCandidates from .strategy import Strategy __all__ = ( \"Strategy\" , \"RefreshCandidates\" , \"HiddenSubset\" , \"HiddenSingle\" , \"PinnedDigit\" , \"ForcedDigit\" , \"NakedDouble\" , \"NakedQuad\" , \"NakedSingle\" , \"NakedSubset\" , \"NakedTriple\" , )","title":"Module sudoku.strategies"},{"location":"reference/sudoku/strategies/#sub-modules","text":"sudoku.strategies.hidden_subset sudoku.strategies.naked_subset sudoku.strategies.refresh_candidates sudoku.strategies.strategy","title":"Sub-modules"},{"location":"reference/sudoku/strategies/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/strategies/#forceddigit","text":"1 2 3 class ForcedDigit ( ) View Source class ForcedDigit ( NakedSingle ) : \"\"\" Alias for the [[NakedSingle]] strategy \"\"\"","title":"ForcedDigit"},{"location":"reference/sudoku/strategies/#ancestors-in-mro","text":"sudoku.strategies.NakedSingle sudoku.strategies.NakedSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#class-variables","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#hiddensingle","text":"1 2 3 class HiddenSingle ( ) View Source class HiddenSingle ( HiddenSubset ) : \"\"\" The [ Hidden Single ]( http : //sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 )","title":"HiddenSingle"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_1","text":"sudoku.strategies.HiddenSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#descendants","text":"sudoku.strategies.PinnedDigit","title":"Descendants"},{"location":"reference/sudoku/strategies/#class-variables_1","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_1","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#hiddensubset","text":"1 2 3 class HiddenSubset ( size ) View Source class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations","title":"HiddenSubset"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_2","text":"sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#descendants_1","text":"sudoku.strategies.HiddenSingle","title":"Descendants"},{"location":"reference/sudoku/strategies/#class-variables_2","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_2","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#nakeddouble","text":"1 2 3 class NakedDouble ( ) View Source class NakedDouble ( NakedSubset ) : \"\"\" Apply the [ Naked Double ]( http : //sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 2 )","title":"NakedDouble"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_3","text":"sudoku.strategies.NakedSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#class-variables_3","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_3","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#nakedquad","text":"1 2 3 class NakedQuad ( ) View Source class NakedQuad ( NakedSubset ) : \"\"\" Apply the [ Naked Quad ]( http : //sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 4 )","title":"NakedQuad"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_4","text":"sudoku.strategies.NakedSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#class-variables_4","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_4","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#nakedsingle","text":"1 2 3 class NakedSingle ( ) View Source class NakedSingle ( NakedSubset ) : \"\"\" The [ Naked Single ]( http : //sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 )","title":"NakedSingle"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_5","text":"sudoku.strategies.NakedSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#descendants_2","text":"sudoku.strategies.ForcedDigit sudoku.strategies.naked_subset.SoleCandidate","title":"Descendants"},{"location":"reference/sudoku/strategies/#class-variables_5","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_5","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#nakedsubset","text":"1 2 3 class NakedSubset ( size : 'int' ) View Source class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations","title":"NakedSubset"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_6","text":"sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#descendants_3","text":"sudoku.strategies.NakedSingle sudoku.strategies.NakedDouble sudoku.strategies.NakedTriple sudoku.strategies.NakedQuad","title":"Descendants"},{"location":"reference/sudoku/strategies/#class-variables_6","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_6","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#nakedtriple","text":"1 2 3 class NakedTriple ( ) View Source class NakedTriple ( NakedSubset ) : \"\"\" Apply the [ Naked Triple ]( http : //sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 3 )","title":"NakedTriple"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_7","text":"sudoku.strategies.NakedSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#class-variables_7","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_7","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#pinneddigit","text":"1 2 3 class PinnedDigit ( ) View Source class PinnedDigit ( HiddenSingle ) : \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\"","title":"PinnedDigit"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_8","text":"sudoku.strategies.HiddenSingle sudoku.strategies.HiddenSubset sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#class-variables_8","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/#instance-variables_8","text":"1 difficulty 1 name 1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/#refreshcandidates","text":"1 2 3 class RefreshCandidates ( ) View Source class RefreshCandidates ( Strategy ) : \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ) : super (). __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ] ) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ) : for _ , peer in puzzle . _peers ( i ) : if cell . is_blank () and not peer . is_blank () : if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations","title":"RefreshCandidates"},{"location":"reference/sudoku/strategies/#ancestors-in-mro_9","text":"sudoku.strategies.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/#instance-variables_9","text":"1 difficulty 1 name","title":"Instance variables"},{"location":"reference/sudoku/strategies/#strategy","text":"1 2 3 4 class Strategy ( name = None , difficulty = None )","title":"Strategy"},{"location":"reference/sudoku/strategies/#attributes","text":"Name Type Description Default name str The name of the strategy None difficulty float The difficulty rating of the strategy defined with respect to eliminating a single candidate None View Source class Strategy : \"\"\" Also known as a [ Solving Technique ]( http : //sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes : name ( str ) : The name of the strategy difficulty ( float ) : The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ) : self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args : puzzle ( Puzzle [ T ]) : The sudoku puzzle Returns : int : The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\"","title":"Attributes"},{"location":"reference/sudoku/strategies/#descendants_4","text":"sudoku.strategies.HiddenSubset sudoku.strategies.NakedSubset sudoku.strategies.RefreshCandidates","title":"Descendants"},{"location":"reference/sudoku/strategies/#instance-variables_10","text":"1 difficulty 1 name","title":"Instance variables"},{"location":"reference/sudoku/strategies/hidden_subset/","text":"Module sudoku.strategies.hidden_subset \u00b6 None None View Source from __future__ import annotations import itertools from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations class HiddenSingle ( HiddenSubset ): \"\"\" The [Hidden Single](http://sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 1 ) class PinnedDigit ( HiddenSingle ): \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\" __all__ = ( \"HiddenSubset\" , \"HiddenSingle\" , \"PinnedDigit\" ) Classes \u00b6 HiddenSingle \u00b6 1 2 3 class HiddenSingle ( ) View Source class HiddenSingle ( HiddenSubset ) : \"\"\" The [ Hidden Single ]( http : //sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 ) Ancestors (in MRO) \u00b6 sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.strategy.Strategy Descendants \u00b6 sudoku.strategies.hidden_subset.PinnedDigit Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size HiddenSubset \u00b6 1 2 3 class HiddenSubset ( size ) View Source class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.strategy.Strategy Descendants \u00b6 sudoku.strategies.hidden_subset.HiddenSingle Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size PinnedDigit \u00b6 1 2 3 class PinnedDigit ( ) View Source class PinnedDigit ( HiddenSingle ) : \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\" Ancestors (in MRO) \u00b6 sudoku.strategies.hidden_subset.HiddenSingle sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.strategy.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size","title":"Hidden Subset"},{"location":"reference/sudoku/strategies/hidden_subset/#module-sudokustrategieshidden_subset","text":"None None View Source from __future__ import annotations import itertools from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations class HiddenSingle ( HiddenSubset ): \"\"\" The [Hidden Single](http://sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 1 ) class PinnedDigit ( HiddenSingle ): \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\" __all__ = ( \"HiddenSubset\" , \"HiddenSingle\" , \"PinnedDigit\" )","title":"Module sudoku.strategies.hidden_subset"},{"location":"reference/sudoku/strategies/hidden_subset/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/strategies/hidden_subset/#hiddensingle","text":"1 2 3 class HiddenSingle ( ) View Source class HiddenSingle ( HiddenSubset ) : \"\"\" The [ Hidden Single ]( http : //sudopedia.enjoysudoku.com/Hidden_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 )","title":"HiddenSingle"},{"location":"reference/sudoku/strategies/hidden_subset/#ancestors-in-mro","text":"sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/hidden_subset/#descendants","text":"sudoku.strategies.hidden_subset.PinnedDigit","title":"Descendants"},{"location":"reference/sudoku/strategies/hidden_subset/#class-variables","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/hidden_subset/#instance-variables","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/hidden_subset/#hiddensubset","text":"1 2 3 class HiddenSubset ( size ) View Source class HiddenSubset ( Strategy ): \"\"\" Apply the [Hidden Subset](http://sudopedia.enjoysudoku.com/Hidden_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) size : int def __init__ ( self , size ): super () . __init__ ( difficulty = 0.163 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .naked_subset import NakedSubset return NakedSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) >= self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: for hidden_candidates in itertools . combinations ( blank . candidates , self . size ): subset = set ( p for p , peer in house ( b ) if ( any (( hc in peer . candidates ) for hc in hidden_candidates )) ) subset . add ( b ) if len ( subset ) == self . size : for s in subset : before_size = len ( puzzle . cells [ s ] . candidates ) puzzle . cells [ s ] . candidates = set ( hidden_candidates ) after_size = len ( puzzle . cells [ s ] . candidates ) candidate_eliminations += before_size - after_size return candidate_eliminations","title":"HiddenSubset"},{"location":"reference/sudoku/strategies/hidden_subset/#ancestors-in-mro_1","text":"sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/hidden_subset/#descendants_1","text":"sudoku.strategies.hidden_subset.HiddenSingle","title":"Descendants"},{"location":"reference/sudoku/strategies/hidden_subset/#class-variables_1","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/hidden_subset/#instance-variables_1","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/hidden_subset/#pinneddigit","text":"1 2 3 class PinnedDigit ( ) View Source class PinnedDigit ( HiddenSingle ) : \"\"\" Alias for the [[HiddenSingle]] strategy \"\"\"","title":"PinnedDigit"},{"location":"reference/sudoku/strategies/hidden_subset/#ancestors-in-mro_2","text":"sudoku.strategies.hidden_subset.HiddenSingle sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/hidden_subset/#class-variables_2","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/hidden_subset/#instance-variables_2","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/","text":"Module sudoku.strategies.naked_subset \u00b6 None None View Source from __future__ import annotations from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations class NakedSingle ( NakedSubset ): \"\"\" The [Naked Single](http://sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 1 ) class ForcedDigit ( NakedSingle ): \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" class SoleCandidate ( NakedSingle ): \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" class NakedDouble ( NakedSubset ): \"\"\" Apply the [Naked Double](http://sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 2 ) class NakedTriple ( NakedSubset ): \"\"\" Apply the [Naked Triple](http://sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 3 ) class NakedQuad ( NakedSubset ): \"\"\" Apply the [Naked Quad](http://sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 4 ) __all__ = ( \"ForcedDigit\" , \"NakedDouble\" , \"NakedQuad\" , \"NakedSingle\" , \"NakedSubset\" , \"NakedTriple\" ) Classes \u00b6 ForcedDigit \u00b6 1 2 3 class ForcedDigit ( ) View Source class ForcedDigit ( NakedSingle ) : \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" Ancestors (in MRO) \u00b6 sudoku.strategies.naked_subset.NakedSingle sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size NakedDouble \u00b6 1 2 3 class NakedDouble ( ) View Source class NakedDouble ( NakedSubset ) : \"\"\" Apply the [ Naked Double ]( http : //sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 2 ) Ancestors (in MRO) \u00b6 sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size NakedQuad \u00b6 1 2 3 class NakedQuad ( ) View Source class NakedQuad ( NakedSubset ) : \"\"\" Apply the [ Naked Quad ]( http : //sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 4 ) Ancestors (in MRO) \u00b6 sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size NakedSingle \u00b6 1 2 3 class NakedSingle ( ) View Source class NakedSingle ( NakedSubset ) : \"\"\" The [ Naked Single ]( http : //sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 ) Ancestors (in MRO) \u00b6 sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy Descendants \u00b6 sudoku.strategies.naked_subset.ForcedDigit sudoku.strategies.naked_subset.SoleCandidate Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size NakedSubset \u00b6 1 2 3 class NakedSubset ( size : 'int' ) View Source class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.strategy.Strategy Descendants \u00b6 sudoku.strategies.naked_subset.NakedSingle sudoku.strategies.naked_subset.NakedDouble sudoku.strategies.naked_subset.NakedTriple sudoku.strategies.naked_subset.NakedQuad Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size NakedTriple \u00b6 1 2 3 class NakedTriple ( ) View Source class NakedTriple ( NakedSubset ) : \"\"\" Apply the [ Naked Triple ]( http : //sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 3 ) Ancestors (in MRO) \u00b6 sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy Class variables \u00b6 1 difficulty 1 name Instance variables \u00b6 1 size","title":"Naked Subset"},{"location":"reference/sudoku/strategies/naked_subset/#module-sudokustrategiesnaked_subset","text":"None None View Source from __future__ import annotations from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations class NakedSingle ( NakedSubset ): \"\"\" The [Naked Single](http://sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 1 ) class ForcedDigit ( NakedSingle ): \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" class SoleCandidate ( NakedSingle ): \"\"\" Alias for the [[NakedSingle]] strategy \"\"\" class NakedDouble ( NakedSubset ): \"\"\" Apply the [Naked Double](http://sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 2 ) class NakedTriple ( NakedSubset ): \"\"\" Apply the [Naked Triple](http://sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 3 ) class NakedQuad ( NakedSubset ): \"\"\" Apply the [Naked Quad](http://sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ): super () . __init__ ( 4 ) __all__ = ( \"ForcedDigit\" , \"NakedDouble\" , \"NakedQuad\" , \"NakedSingle\" , \"NakedSubset\" , \"NakedTriple\" )","title":"Module sudoku.strategies.naked_subset"},{"location":"reference/sudoku/strategies/naked_subset/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/strategies/naked_subset/#forceddigit","text":"1 2 3 class ForcedDigit ( ) View Source class ForcedDigit ( NakedSingle ) : \"\"\" Alias for the [[NakedSingle]] strategy \"\"\"","title":"ForcedDigit"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro","text":"sudoku.strategies.naked_subset.NakedSingle sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/#nakeddouble","text":"1 2 3 class NakedDouble ( ) View Source class NakedDouble ( NakedSubset ) : \"\"\" Apply the [ Naked Double ]( http : //sudopedia.enjoysudoku.com/Naked_Double.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 2 )","title":"NakedDouble"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro_1","text":"sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables_1","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables_1","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/#nakedquad","text":"1 2 3 class NakedQuad ( ) View Source class NakedQuad ( NakedSubset ) : \"\"\" Apply the [ Naked Quad ]( http : //sudopedia.enjoysudoku.com/Naked_Quad.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 4 )","title":"NakedQuad"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro_2","text":"sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables_2","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables_2","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/#nakedsingle","text":"1 2 3 class NakedSingle ( ) View Source class NakedSingle ( NakedSubset ) : \"\"\" The [ Naked Single ]( http : //sudopedia.enjoysudoku.com/Naked_Single.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 1 )","title":"NakedSingle"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro_3","text":"sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#descendants","text":"sudoku.strategies.naked_subset.ForcedDigit sudoku.strategies.naked_subset.SoleCandidate","title":"Descendants"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables_3","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables_3","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/#nakedsubset","text":"1 2 3 class NakedSubset ( size : 'int' ) View Source class NakedSubset ( Strategy ): \"\"\" Apply the [Naked Subset](http://sudopedia.enjoysudoku.com/Naked_Subset.html) strategy \"\"\" __slots__ = ( \"size\" ,) def __init__ ( self , size : int ): super () . __init__ ( difficulty = 0.323 * size ) self . name += f \" - { size } \" self . size = size def __call__ ( self , puzzle : Puzzle [ T ]) -> int : if self . size <= 0 or self . size >= puzzle . order : return 0 complement_size = puzzle . order - self . size if complement_size < self . size : from .hidden_subset import HiddenSubset return HiddenSubset ( complement_size )( puzzle ) candidate_eliminations = 0 for b , blank in puzzle . _blank (): if len ( blank . candidates ) == self . size : for house in [ puzzle . _row , puzzle . _col , puzzle . _box ]: complement = set ( p for p , peer in house ( b ) if ( len ( peer . candidates ) > self . size or any (( pc not in blank . candidates ) for pc in peer . candidates ) ) ) if len ( complement ) == complement_size : for p in complement : for c in blank . candidates : if c in puzzle . cells [ p ] . candidates : puzzle . cells [ p ] . candidates . remove ( c ) candidate_eliminations += 1 return candidate_eliminations","title":"NakedSubset"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro_4","text":"sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#descendants_1","text":"sudoku.strategies.naked_subset.NakedSingle sudoku.strategies.naked_subset.NakedDouble sudoku.strategies.naked_subset.NakedTriple sudoku.strategies.naked_subset.NakedQuad","title":"Descendants"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables_4","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables_4","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/naked_subset/#nakedtriple","text":"1 2 3 class NakedTriple ( ) View Source class NakedTriple ( NakedSubset ) : \"\"\" Apply the [ Naked Triple ]( http : //sudopedia.enjoysudoku.com/Naked_Triple.html) strategy \"\"\" def __init__ ( self ) : super (). __init__ ( 3 )","title":"NakedTriple"},{"location":"reference/sudoku/strategies/naked_subset/#ancestors-in-mro_5","text":"sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/naked_subset/#class-variables_5","text":"1 difficulty 1 name","title":"Class variables"},{"location":"reference/sudoku/strategies/naked_subset/#instance-variables_5","text":"1 size","title":"Instance variables"},{"location":"reference/sudoku/strategies/refresh_candidates/","text":"Module sudoku.strategies.refresh_candidates \u00b6 None None View Source from __future__ import annotations from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class RefreshCandidates ( Strategy ): \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ): super () . __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ]) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ): for _ , peer in puzzle . _peers ( i ): if cell . is_blank () and not peer . is_blank (): if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations __all__ = \"RefreshCandidates\" Classes \u00b6 RefreshCandidates \u00b6 1 2 3 class RefreshCandidates ( ) View Source class RefreshCandidates ( Strategy ) : \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ) : super (). __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ] ) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ) : for _ , peer in puzzle . _peers ( i ) : if cell . is_blank () and not peer . is_blank () : if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations Ancestors (in MRO) \u00b6 sudoku.strategies.strategy.Strategy Instance variables \u00b6 1 difficulty 1 name","title":"Refresh Candidates"},{"location":"reference/sudoku/strategies/refresh_candidates/#module-sudokustrategiesrefresh_candidates","text":"None None View Source from __future__ import annotations from typing import TYPE_CHECKING from .strategy import Strategy if TYPE_CHECKING : from ..puzzle import Puzzle , T class RefreshCandidates ( Strategy ): \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ): super () . __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ]) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ): for _ , peer in puzzle . _peers ( i ): if cell . is_blank () and not peer . is_blank (): if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations __all__ = \"RefreshCandidates\"","title":"Module sudoku.strategies.refresh_candidates"},{"location":"reference/sudoku/strategies/refresh_candidates/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/strategies/refresh_candidates/#refreshcandidates","text":"1 2 3 class RefreshCandidates ( ) View Source class RefreshCandidates ( Strategy ) : \"\"\" Remove invalid candidates from each cell \"\"\" def __init__ ( self ) : super (). __init__ ( difficulty = 0.769 ) def __call__ ( self , puzzle : Puzzle [ T ] ) -> int : candidate_eliminations = 0 for i , cell in enumerate ( puzzle . cells ) : for _ , peer in puzzle . _peers ( i ) : if cell . is_blank () and not peer . is_blank () : if peer . value in cell . candidates : cell . candidates . remove ( peer . value ) candidate_eliminations += 1 return candidate_eliminations","title":"RefreshCandidates"},{"location":"reference/sudoku/strategies/refresh_candidates/#ancestors-in-mro","text":"sudoku.strategies.strategy.Strategy","title":"Ancestors (in MRO)"},{"location":"reference/sudoku/strategies/refresh_candidates/#instance-variables","text":"1 difficulty 1 name","title":"Instance variables"},{"location":"reference/sudoku/strategies/strategy/","text":"Module sudoku.strategies.strategy \u00b6 None None View Source from __future__ import annotations from typing import TYPE_CHECKING if TYPE_CHECKING : from ..puzzle import Puzzle , T class Strategy : \"\"\" Also known as a [Solving Technique](http://sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes: name (str): The name of the strategy difficulty (float): The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ): self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args: puzzle (Puzzle[T]): The sudoku puzzle Returns: int: The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\" __all__ = ( \"Strategy\" ,) Classes \u00b6 Strategy \u00b6 1 2 3 4 class Strategy ( name = None , difficulty = None ) Attributes \u00b6 Name Type Description Default name str The name of the strategy None difficulty float The difficulty rating of the strategy defined with respect to eliminating a single candidate None View Source class Strategy : \"\"\" Also known as a [ Solving Technique ]( http : //sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes : name ( str ) : The name of the strategy difficulty ( float ) : The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ) : self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args : puzzle ( Puzzle [ T ]) : The sudoku puzzle Returns : int : The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\" Descendants \u00b6 sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.refresh_candidates.RefreshCandidates Instance variables \u00b6 1 difficulty 1 name","title":"Strategy"},{"location":"reference/sudoku/strategies/strategy/#module-sudokustrategiesstrategy","text":"None None View Source from __future__ import annotations from typing import TYPE_CHECKING if TYPE_CHECKING : from ..puzzle import Puzzle , T class Strategy : \"\"\" Also known as a [Solving Technique](http://sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes: name (str): The name of the strategy difficulty (float): The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ): self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args: puzzle (Puzzle[T]): The sudoku puzzle Returns: int: The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\" __all__ = ( \"Strategy\" ,)","title":"Module sudoku.strategies.strategy"},{"location":"reference/sudoku/strategies/strategy/#classes","text":"","title":"Classes"},{"location":"reference/sudoku/strategies/strategy/#strategy","text":"1 2 3 4 class Strategy ( name = None , difficulty = None )","title":"Strategy"},{"location":"reference/sudoku/strategies/strategy/#attributes","text":"Name Type Description Default name str The name of the strategy None difficulty float The difficulty rating of the strategy defined with respect to eliminating a single candidate None View Source class Strategy : \"\"\" Also known as a [ Solving Technique ]( http : //sudopedia.enjoysudoku.com/Solving_Technique.html) Attributes : name ( str ) : The name of the strategy difficulty ( float ) : The difficulty rating of the strategy defined with respect to eliminating a single candidate \"\"\" __slots__ = \"name\" , \"difficulty\" name : str difficulty : float def __init__ ( self , name = None , difficulty = None ) : self . name = name if name is not None else self . __class__ . __name__ self . difficulty = difficulty def __call__ ( self , puzzle : Puzzle [ T ]) -> int : \"\"\" Apply the strategy to a given sudoku puzzle Args : puzzle ( Puzzle [ T ]) : The sudoku puzzle Returns : int : The number of candidates eliminated by the strategy with a single pass over the sudoku puzzle \"\"\"","title":"Attributes"},{"location":"reference/sudoku/strategies/strategy/#descendants","text":"sudoku.strategies.hidden_subset.HiddenSubset sudoku.strategies.naked_subset.NakedSubset sudoku.strategies.refresh_candidates.RefreshCandidates","title":"Descendants"},{"location":"reference/sudoku/strategies/strategy/#instance-variables","text":"1 difficulty 1 name","title":"Instance variables"}]}